Collection: add(Object obj) addAll(Collection c) size() clear() isEmpty()
		remove(Object obj) removeAll(Collection c)  retainAll(Collection c)
		contains(Object obj)  containAll(Collection c)  hashCode()  iterator()
		toArray()
	
	-->List：有序，可以有重复储存元素
		特有的方法：add(int index, Object obj)  remove(int index)
				Object set(int index, Object obj)
				Object get(int index)  		   int indexOf(Object obj)
				int lastIndexOf(Object obj)    List subList(int from, int to)
		-->ArrayList：内部是一个数组结构，不同步，代替了vector，查询快
		-->LinkedList：内部数据结构是一个链表，不同步，增删快
		-->Vector：内部数据结构也是数组，同步的，增删查都慢
	
	
	-->Set：无序，元素唯一
		Set接口与Collection接口中的方法一致
		
		-->HashSet：内部数据结构hashCode是哈希表，不同步
				怎么保证存储的元素是唯一的？
					通过对象的hashCode和equals方法来确定
				如果对象的hashCode不同，就不用判断equals方法了；直接存储到集合中
				如果对象的hashCode相同，就需要根据equals方法进行判断
							如果结果为true，视为相同，不再进行存储
							如果结果为false，视为不同，就进行存储
				注意：如果元素存储到hashSet中，必须要覆盖hashCode和equals方法
					尽量这两个方法保持一致
				
			-->LinkedHashSet：是其子类，当我们遍历集合时，是按照我们添加的顺序进行的
					频繁的遍历，但是增删比较少，可以选择使用这种
					
		-->TreeSet：可以对元素进行排序，也是不同步的
				判断元素唯一性的方式：就是根据比较方法反悔的结构；0（相同）时不再存储
				排序方式：
					1.元素自身具有比较的功能，实现Comparable接口，重写ComparaTo方法
					2.元素自身不具有比较功能，没有实现Comparable接口，这时定义一个类，实现Comparator接口，重写ComparaTo方法
	
	
Map:
	
	-->HashMap
	
	
	-->TreeMap
	
	
	-->HashTable